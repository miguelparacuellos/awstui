{"version":3,"sources":["../src/ScrollView.tsx","../src/ControlledScrollView.tsx"],"sourcesContent":["import React, {\n  useState,\n  useRef,\n  forwardRef,\n  useImperativeHandle,\n  useCallback,\n  ReactNode,\n} from \"react\";\nimport { BoxProps } from \"ink\";\nimport {\n  ControlledScrollView,\n  ControlledScrollViewRef,\n} from \"./ControlledScrollView\";\n\n/**\n * Props for the ScrollView component.\n *\n * @remarks\n * Extends standard BoxProps from Ink.\n */\nexport interface ScrollViewProps extends BoxProps {\n  /**\n   * Callback fired when the scroll position changes.\n   *\n   * @param scrollOffset - The new scroll offset (distance from top).\n   *\n   * @remarks\n   * Use this to sync external state or UI (e.g., scrollbars) with the current scroll position.\n   */\n  onScroll?: (scrollOffset: number) => void;\n\n  /**\n   * Callback fired when the ScrollView viewport (visible area) dimensions change.\n   *\n   * @param size - The new dimensions of the viewport (width, height).\n   * @param previousSize - The previous dimensions of the viewport (width, height).\n   *\n   * @remarks\n   * Fired whenever the outer container size changes (e.g., terminal resize or layout update).\n   */\n  onViewportSizeChange?: (\n    size: { width: number; height: number },\n    previousSize: { width: number; height: number },\n  ) => void;\n\n  /**\n   * Callback fired when the total height of the content changes.\n   *\n   * @param height - The new total content height.\n   * @param previousHeight - The previous total content height.\n   *\n   * @remarks\n   * Useful for debug logging or adjusting external layouts based on content size.\n   */\n  onContentHeightChange?: (height: number, previousHeight: number) => void;\n\n  /**\n   * Callback fired when an individual child item's height changes.\n   *\n   * @param index - The index of the item.\n   * @param height - The new height of the item.\n   * @param previousHeight - The previous height of the item.\n   *\n   * @remarks\n   * This is triggered whenever an item is re-measured and its height differs from the previous value.\n   */\n  onItemHeightChange?: (\n    index: number,\n    height: number,\n    previousHeight: number,\n  ) => void;\n\n  /**\n   * Enable debug mode to visualize the ScrollView internals.\n   *\n   * @remarks\n   * When enabled, the viewport overflow is not hidden, allowing the full content\n   * to be visible. This is useful for inspecting the layout and verifying\n   * that content is being rendered correctly off-screen.\n   */\n  debug?: boolean;\n\n  /**\n   * The content to be scrolled.\n   *\n   * @remarks\n   * Accepts an array of React elements. Each element should have a unique `key`\n   * prop, which will be preserved during rendering for proper reconciliation.\n   */\n  children?: ReactNode;\n}\n\n/**\n * Ref interface for controlling the ScrollView programmatically.\n */\nexport interface ScrollViewRef {\n  /**\n   * Scrolls to a specific vertical position.\n   *\n   * @param offset - The target Y offset (distance from top).\n   *\n   * @example\n   * ```tsx\n   * // Scroll to the very top\n   * ref.current?.scrollTo(0);\n   * ```\n   */\n  scrollTo: (offset: number) => void;\n\n  /**\n   * Scrolls by a relative amount.\n   *\n   * @param delta - Positive for down, negative for up.\n   *\n   * @example\n   * ```tsx\n   * useInput((input, key) => {\n   *   if (key.downArrow) ref.current?.scrollBy(1);\n   *   if (key.upArrow) ref.current?.scrollBy(-1);\n   * });\n   * ```\n   */\n  scrollBy: (delta: number) => void;\n\n  /**\n   * Scrolls to the very top (position 0).\n   */\n  scrollToTop: () => void;\n\n  /**\n   * Scrolls to the very bottom.\n   *\n   * @remarks\n   * This calculates the target offset as `contentHeight - viewportHeight`.\n   */\n  scrollToBottom: () => void;\n\n  /**\n   * Gets the current scroll offset (distance scrolled from the top).\n   *\n   * @remarks\n   * The scroll offset represents how many terminal rows the content has been\n   * scrolled up from its initial position. A value of 0 means the content is\n   * at the very top (no scrolling has occurred).\n   *\n   * @returns The current scroll offset in terminal rows.\n   */\n  getScrollOffset: () => number;\n\n  /**\n   * Gets the total height of the content.\n   *\n   * @remarks\n   * This is the sum of the heights of all child items.\n   *\n   * @returns The total content height in terminal rows.\n   */\n  getContentHeight: () => number;\n\n  /**\n   * Gets the current height of the visible viewport.\n   *\n   * @returns The viewport height in terminal rows.\n   */\n  getViewportHeight: () => number;\n\n  /**\n   * Gets the scroll offset when the content is scrolled to the very bottom.\n   *\n   * @remarks\n   * This is calculated as `contentHeight - viewportHeight`. When the scroll\n   * offset equals this value, the last item of the content is visible at the\n   * bottom of the viewport.\n   *\n   * @returns The bottom scroll offset in terminal rows.\n   */\n  getBottomOffset: () => number;\n\n  /**\n   * Gets the height of a specific item by its index.\n   *\n   * @param index - The index of the item.\n   * @returns The height of the item in terminal rows, or 0 if not found.\n   */\n  getItemHeight: (index: number) => number;\n\n  /**\n   * Gets the position of a specific item.\n   *\n   * @param index - The index of the item.\n   * @returns The position (top offset) and height of the item, or null if not found.\n   */\n  getItemPosition: (index: number) => { top: number; height: number } | null;\n\n  /**\n   * Re-measures the ScrollView viewport dimensions.\n   *\n   * @remarks\n   * Checks the current dimensions of the viewport and updates state if they have changed.\n   * This is crucial for handling terminal resizes, as Ink does not automatically propagate resize events to components.\n   *\n   * @example\n   * ```tsx\n   * // Handle terminal resize manually\n   * useEffect(() => {\n   *   const onResize = () => ref.current?.remeasure();\n   *   process.stdout.on('resize', onResize);\n   *   return () => process.stdout.off('resize', onResize);\n   * }, []);\n   * ```\n   */\n  remeasure: () => void;\n\n  /**\n   * Triggers re-measurement of a specific child item.\n   *\n   * @param index - The index of the child to re-measure.\n   *\n   * @remarks\n   * Use this if a child's internal content changes size in a way that doesn't trigger a standard React render cycle update\n   * (e.g., internal state change within the child that affects its height).\n   */\n  remeasureItem: (index: number) => void;\n}\n\n/**\n * Hook to manage state with immediate ref synchronization.\n * Useful for values that need to be read synchronously in imperative methods\n * but also trigger re-renders when changed.\n */\nfunction useStateRef<T>(initialValue: T) {\n  const [state, setStateInternal] = useState<T>(initialValue);\n  const ref = useRef<T>(initialValue);\n\n  const setState = useCallback((update: React.SetStateAction<T>) => {\n    const nextValue =\n      typeof update === \"function\"\n        ? (update as (prev: T) => T)(ref.current)\n        : update;\n    ref.current = nextValue;\n    setStateInternal(nextValue);\n  }, []);\n\n  const getState = useCallback(() => ref.current, []);\n\n  return [state, setState, getState] as const;\n}\n\n/**\n * A ScrollView component for Ink applications.\n *\n * @remarks\n * Allows scrolling through content that exceeds the visible area of the terminal.\n * It manages a virtual viewport and renders all children, but strictly controls\n * their visibility using `overflow=\"hidden\"` and `marginTop` offsets.\n *\n * **Features:**\n * - â†•ï¸ Vertical scrolling\n * - ðŸ“ Auto-measurement of child heights\n * - ðŸŽ¯ Imperative scrolling methods via ref\n * - ðŸ” Dynamic content support (adding/removing children)\n * - ðŸ–¥ï¸ Viewport resize handling (via manual `remeasure`)\n *\n * **Important Notes:**\n * - This component does NOT automatically capture keyboard input. You must use `useInput` in a parent component and control the scroll via the `onInput` hook or similar.\n * - Children MUST generally have specific keys if you plan to dynamically update them, to ensure correct height tracking across renders.\n *\n *\n * @example\n * ```tsx\n * import React, { useRef } from 'react';\n * import { Box, Text, useInput } from 'ink';\n * import { ScrollView, ScrollViewRef } from 'ink-scroll-view';\n *\n * const Demo = () => {\n *   const scrollRef = useRef<ScrollViewRef>(null);\n *\n *   useInput((input, key) => {\n *     if (key.downArrow) {\n *       scrollRef.current?.scrollBy(1);\n *     }\n *     if (key.upArrow) {\n *       scrollRef.current?.scrollBy(-1);\n *     }\n *   });\n *\n *   return (\n *     <Box height={10} borderStyle=\"single\">\n *       <ScrollView ref={scrollRef}>\n *         {items.map(item => (\n *           <Text key={item.id}>{item.label}</Text>\n *         ))}\n *       </ScrollView>\n *     </Box>\n *   );\n * };\n * ```\n */\nexport const ScrollView = forwardRef<ScrollViewRef, ScrollViewProps>(\n  (\n    {\n      onScroll,\n      onViewportSizeChange,\n      onContentHeightChange,\n      onItemHeightChange,\n      debug = false,\n      children,\n      ...boxProps\n    },\n    ref,\n  ) => {\n    // Current scroll position (offset from top).\n    const [scrollOffset, setScrollOffset, getScrollOffset] = useStateRef(0);\n\n    const innerRef = useRef<ControlledScrollViewRef>(null);\n\n    // Track content height to handle clamping\n    const contentHeightRef = useRef(0);\n\n    const handleContentHeightChange = useCallback(\n      (height: number, previousHeight: number) => {\n        contentHeightRef.current = height;\n        onContentHeightChange?.(height, previousHeight);\n\n        // Clamp scroll position if it exceeds the new max scroll.\n        // This ensures the view doesn't get \"stuck\" showing empty space if content shrinks.\n        if (getScrollOffset() > height) {\n          setScrollOffset(height);\n          onScroll?.(height);\n        }\n      },\n      [onContentHeightChange, onScroll, getScrollOffset, setScrollOffset],\n    );\n\n    // Helper to calculate the bottom scroll offset\n    const getBottomOffset = useCallback(\n      () =>\n        Math.max(\n          0,\n          contentHeightRef.current -\n            (innerRef.current?.getViewportHeight() || 0),\n        ),\n      [],\n    );\n\n    // Expose control methods to parent via ref\n    useImperativeHandle(\n      ref,\n      () => ({\n        scrollTo: (offset: number) => {\n          if (typeof offset !== \"number\" || isNaN(offset)) {\n            return;\n          }\n          const currentContentHeight = contentHeightRef.current;\n          const newScrollTop = Math.max(\n            0,\n            Math.min(offset, currentContentHeight),\n          );\n          if (newScrollTop !== getScrollOffset()) {\n            setScrollOffset(newScrollTop);\n            onScroll?.(newScrollTop);\n          }\n        },\n        scrollBy: (delta: number) => {\n          if (typeof delta !== \"number\" || isNaN(delta)) {\n            return;\n          }\n          const currentContentHeight = contentHeightRef.current;\n          const newScrollTop = Math.max(\n            0,\n            Math.min(getScrollOffset() + delta, currentContentHeight),\n          );\n          if (newScrollTop !== getScrollOffset()) {\n            setScrollOffset(newScrollTop);\n            onScroll?.(newScrollTop);\n          }\n        },\n        scrollToTop: () => {\n          if (getScrollOffset() !== 0) {\n            setScrollOffset(0);\n            onScroll?.(0);\n          }\n        },\n        scrollToBottom: () => {\n          const bottomOffset = getBottomOffset();\n          if (getScrollOffset() !== bottomOffset) {\n            setScrollOffset(bottomOffset);\n            onScroll?.(bottomOffset);\n          }\n        },\n        getScrollOffset,\n        getContentHeight: () => contentHeightRef.current,\n        getViewportHeight: () => innerRef.current?.getViewportHeight() || 0,\n        getBottomOffset,\n        getItemHeight: (index: number) =>\n          innerRef.current?.getItemHeight(index) || 0,\n        getItemPosition: (index: number) =>\n          innerRef.current?.getItemPosition(index) || null,\n        remeasure: () => innerRef.current?.remeasure(),\n        remeasureItem: (index: number) =>\n          innerRef.current?.remeasureItem(index),\n      }),\n      [onScroll, getBottomOffset, getScrollOffset, setScrollOffset],\n    );\n\n    return (\n      <ControlledScrollView\n        ref={innerRef}\n        scrollOffset={scrollOffset}\n        onViewportSizeChange={onViewportSizeChange}\n        onContentHeightChange={handleContentHeightChange}\n        onItemHeightChange={onItemHeightChange}\n        debug={debug}\n        children={children}\n        {...boxProps}\n      />\n    );\n  },\n);\n","import React, {\n  useState,\n  useRef,\n  forwardRef,\n  useImperativeHandle,\n  useLayoutEffect,\n  useCallback,\n  Children,\n  ReactNode,\n  isValidElement,\n} from \"react\";\nimport { Box, BoxProps, measureElement, DOMElement } from \"ink\";\n\n/**\n * Internal helper component to measure the height of each child item.\n *\n * @internal\n * @remarks\n * This component wraps each child in a Box and uses `measureElement` from `ink`\n * to determine its dimensions. It reports the height back to the parent via `onMeasure`.\n *\n * It uses `useLayoutEffect` to measure synchronously after rendering to ensure\n * layout stability and prevent flickering.\n */\nconst MeasurableItem = ({\n  children,\n  onMeasure,\n  index,\n  width,\n  measureKey,\n}: {\n  children: ReactNode;\n  onMeasure: (index: number, height: number) => void;\n  index: number;\n  width: number;\n  // Used to force re-measurement even if other props haven't changed\n  measureKey?: number;\n}) => {\n  const ref = useRef<DOMElement>(null);\n\n  useLayoutEffect(() => {\n    if (ref.current) {\n      const { height } = measureElement(ref.current);\n      onMeasure(index, height);\n    }\n  }, [index, onMeasure, width, measureKey, children]);\n\n  return (\n    <Box ref={ref} flexShrink={0} width=\"100%\" flexDirection=\"column\">\n      {children}\n    </Box>\n  );\n};\n\n/**\n * Hook to manage state with immediate ref synchronization.\n * Useful for values that need to be read synchronously in imperative methods\n * but also trigger re-renders when changed.\n */\nfunction useStateRef<T>(initialValue: T) {\n  const [state, setStateInternal] = useState<T>(initialValue);\n  const ref = useRef<T>(initialValue);\n\n  const setState = useCallback((update: React.SetStateAction<T>) => {\n    const nextValue =\n      typeof update === \"function\"\n        ? (update as (prev: T) => T)(ref.current)\n        : update;\n    ref.current = nextValue;\n    setStateInternal(nextValue);\n  }, []);\n\n  const getState = useCallback(() => ref.current, []);\n\n  return [state, setState, getState] as const;\n}\n\nexport interface ControlledScrollViewProps extends BoxProps {\n  /**\n   * The current scroll offset (distance from top).\n   * Controlled by the parent.\n   */\n  scrollOffset: number;\n\n  /**\n   * Callback fired when the ScrollView viewport (visible area) dimensions change.\n   */\n  onViewportSizeChange?: (\n    size: { width: number; height: number },\n    previousSize: { width: number; height: number },\n  ) => void;\n\n  /**\n   * Callback fired when the total height of the content changes.\n   */\n  onContentHeightChange?: (height: number, previousHeight: number) => void;\n\n  /**\n   * Callback fired when an individual child item's height changes.\n   */\n  onItemHeightChange?: (\n    index: number,\n    height: number,\n    previousHeight: number,\n  ) => void;\n\n  /**\n   * Enable debug mode to visualize the ScrollView internals.\n   */\n  debug?: boolean;\n\n  children?: ReactNode;\n}\n\nexport interface ControlledScrollViewRef {\n  /**\n   * Gets the total height of the content.\n   *\n   * @returns The sum of heights of all child items.\n   */\n  getContentHeight: () => number;\n\n  /**\n   * Gets the current height of the visible viewport.\n   *\n   * @returns The height of the viewport container.\n   */\n  getViewportHeight: () => number;\n\n  /**\n   * Gets the maximum scroll offset (content height - viewport height).\n   *\n   * @remarks\n   * This represents the scroll offset required to view the very bottom of the content.\n   * It is clamped to 0 if the content fits entirely within the viewport.\n   */\n  getBottomOffset: () => number;\n\n  /**\n   * Gets the height of a specific item by its index.\n   *\n   * @param index - The index of the child item.\n   * @returns The measured height of the item.\n   */\n  getItemHeight: (index: number) => number;\n\n  /**\n   * Gets the absolute position and dimensions of a specific item.\n   *\n   * @param index - The index of the child item.\n   * @returns Object containing `top` (offset from content start) and `height`, or `null` if the index is invalid.\n   *\n   * @remarks\n   * This method uses a cached offset calculation system (`itemOffsetsRef`) for performance.\n   * It calculates offsets lazily and caches them until the underlying measurements change.\n   */\n  getItemPosition: (index: number) => { top: number; height: number } | null;\n\n  /**\n   * Re-measures the ScrollView viewport dimensions.\n   *\n   * @remarks\n   * Explicitly triggers a measurement of the viewport Box. This is necessary because\n   * Ink does not automatically detect terminal window resizes or parent layout changes\n   * that might affect the viewport size.\n   */\n  remeasure: () => void;\n\n  /**\n   * Triggers re-measurement of a specific child item.\n   *\n   * @param index - The index of the child to re-measure.\n   *\n   * @remarks\n   * Forces the `MeasurableItem` wrapper for the specified index to re-run `measureElement`.\n   * Use this when a child's content changes internally (e.g., expanding text) without changing props.\n   */\n  remeasureItem: (index: number) => void;\n}\n\n/**\n * A ControlledScrollView component for Ink applications.\n *\n * @remarks\n * This is a lower-level component that handles the complex logic of:\n * 1. Rendering children within a virtual viewport.\n * 2. Continuously measuring child heights.\n * 3. Calculating total content height.\n * 4. Managing viewport wrapping adjustments (`marginTop`).\n *\n * It is \"controlled\" because it does not maintain its own scroll state; it purely renders\n * based on the provided `scrollOffset` prop. This allows for flexible parent-controlled behavior.\n */\nexport const ControlledScrollView = forwardRef<\n  ControlledScrollViewRef,\n  ControlledScrollViewProps\n>(\n  (\n    {\n      scrollOffset,\n      onViewportSizeChange,\n      onContentHeightChange,\n      onItemHeightChange,\n      debug = false,\n      children,\n      ...boxProps\n    },\n    ref,\n  ) => {\n    // Viewport dimensions (visible area)\n    const [viewportSize, setViewportSize, getViewportSize] = useStateRef({\n      height: 0,\n      width: 0,\n    });\n\n    // Total height of the scrollable content\n    const [contentHeight, setContentHeight, getContentHeight] = useStateRef(0);\n\n    // Per-item measure keys to force re-measurement of specific items\n    const [itemMeasureKeys, setItemMeasureKeys] = useState<\n      Record<number, number>\n    >({});\n\n    const viewportRef = useRef<DOMElement>(null);\n    const contentRef = useRef<DOMElement>(null);\n\n    // Track previous content height to fire the change callback\n    const prevContentHeightRef = useRef(0);\n\n    useLayoutEffect(() => {\n      if (contentHeight !== prevContentHeightRef.current) {\n        onContentHeightChange?.(contentHeight, prevContentHeightRef.current);\n        prevContentHeightRef.current = contentHeight;\n      }\n    }, [contentHeight, onContentHeightChange]);\n\n    /**\n     * Map of item unique keys (or indices) to their measured heights.\n     * Used to calculate total content height and individual item offsets.\n     */\n    const itemHeightsRef = useRef<Record<string | number, number>>({});\n\n    /**\n     * Map of child index to their unique key.\n     * Preserves the association between standard array indices and React element keys.\n     */\n    const itemKeysRef = useRef<(string | number)[]>([]);\n\n    /**\n     * Cache of accumulated item offset positions (distance from top).\n     * `itemOffsetsRef.current[i]` stores the `top` position of item `i`.\n     *\n     * @remarks\n     * This cache is strictly lazy. It is populated only when `getItemPosition` is called.\n     * The `firstInvalidOffsetIndexRef` tracks which part of the cache is valid.\n     */\n    const itemOffsetsRef = useRef<number[]>([]);\n\n    /**\n     * The index of the first item whose cached offset is considered invalid/dirty.\n     *\n     * @remarks\n     * When an item's height changes, all subsequent items' offsets become incorrect.\n     * We set this index to the changed item's index.\n     * When querying positions, we recalculate offsets from this index onwards.\n     */\n    const firstInvalidOffsetIndexRef = useRef<number>(0);\n\n    const handleItemMeasure = useCallback(\n      (index: number, height: number) => {\n        // Identify the item by its stable key (or index if no key provided)\n        const key = itemKeysRef.current[index] || index;\n\n        // Check if the measurement has actually changed to avoid unnecessary updates\n        if (itemHeightsRef.current[key] !== height) {\n          const previousHeight = itemHeightsRef.current[key] || 0;\n\n          // Update the height map\n          itemHeightsRef.current = {\n            ...itemHeightsRef.current,\n            [key]: height,\n          };\n\n          // Recalculate total content height\n          let newTotalHeight = 0;\n          for (const itemKey of itemKeysRef.current) {\n            newTotalHeight += itemHeightsRef.current[itemKey] || 0;\n          }\n\n          const currentHeight = getContentHeight();\n          if (newTotalHeight !== currentHeight) {\n            setContentHeight(newTotalHeight);\n          }\n\n          // Notify parent of the specific item change\n          onItemHeightChange?.(index, height, previousHeight);\n\n          // Invalidate the offset cache starting from this item\n          // because if this item's height changed, all items below it have shifted.\n          firstInvalidOffsetIndexRef.current = Math.min(\n            firstInvalidOffsetIndexRef.current,\n            index + 1,\n          );\n        }\n      },\n      [\n        onItemHeightChange,\n        onContentHeightChange,\n        getContentHeight,\n        setContentHeight,\n      ],\n    );\n\n    const measureViewport = useCallback(() => {\n      if (viewportRef.current) {\n        const { width, height } = measureElement(viewportRef.current);\n        const currentSize = getViewportSize();\n        if (width !== currentSize.width || height !== currentSize.height) {\n          onViewportSizeChange?.({ width, height }, currentSize);\n          setViewportSize({ width, height });\n        }\n      }\n    }, [viewportRef, onViewportSizeChange, getViewportSize, setViewportSize]);\n\n    useLayoutEffect(() => {\n      measureViewport();\n    });\n\n    const prevChildrenRef = useRef<typeof children>(null);\n    if (prevChildrenRef.current !== children) {\n      prevChildrenRef.current = children;\n\n      const newItemKeys: (string | number)[] = [];\n      const newItemHeights: Record<string | number, number> = {};\n\n      Children.forEach(children, (child, index) => {\n        if (!child) return;\n        const key = isValidElement(child) ? child.key : null;\n        const effectiveKey = key !== null ? key : index;\n\n        newItemKeys[index] = effectiveKey;\n        const itemHeight = itemHeightsRef.current[effectiveKey] || 0;\n        newItemHeights[effectiveKey] = itemHeight;\n      });\n\n      itemHeightsRef.current = newItemHeights;\n      itemKeysRef.current = newItemKeys;\n      itemOffsetsRef.current = new Array(newItemKeys.length).fill(0);\n      firstInvalidOffsetIndexRef.current = 0;\n\n      let newTotalHeight = 0;\n      newItemKeys.forEach((itemKey) => {\n        newTotalHeight += newItemHeights[itemKey] || 0;\n      });\n\n      const currentHeight = getContentHeight();\n      if (newTotalHeight !== currentHeight) {\n        setContentHeight(newTotalHeight);\n      }\n    }\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        getContentHeight,\n        getViewportHeight: () => getViewportSize().height,\n        getBottomOffset: () =>\n          Math.max(0, getContentHeight() - getViewportSize().height),\n        getItemHeight: (index: number) => {\n          const key = itemKeysRef.current[index] || index;\n          return itemHeightsRef.current[key] || 0;\n        },\n        remeasure: measureViewport,\n        remeasureItem: (index: number) =>\n          setItemMeasureKeys((prev) => ({\n            ...prev,\n            [index]: (prev[index] || 0) + 1,\n          })),\n        getItemPosition: (index: number) => {\n          if (index < 0 || index >= itemKeysRef.current.length) {\n            return null;\n          }\n\n          if (index >= firstInvalidOffsetIndexRef.current) {\n            let currentOffset = 0;\n            let startIndex = 0;\n\n            if (firstInvalidOffsetIndexRef.current > 0) {\n              startIndex = firstInvalidOffsetIndexRef.current;\n              const prevIndex = startIndex - 1;\n              const prevKey = itemKeysRef.current[prevIndex] || prevIndex;\n              const prevHeight = itemHeightsRef.current[prevKey] || 0;\n              currentOffset =\n                (itemOffsetsRef.current[prevIndex] ?? 0) + prevHeight;\n            }\n\n            for (let i = startIndex; i <= index; i++) {\n              itemOffsetsRef.current[i] = currentOffset;\n              const key = itemKeysRef.current[i] || i;\n              const height = itemHeightsRef.current[key] || 0;\n              currentOffset += height;\n            }\n            firstInvalidOffsetIndexRef.current = index + 1;\n          }\n\n          const top = itemOffsetsRef.current[index] ?? 0;\n          const key = itemKeysRef.current[index] || index;\n          const height = itemHeightsRef.current[key] || 0;\n          return { top, height };\n        },\n      }),\n      [],\n    );\n\n    return (\n      <Box {...boxProps}>\n        <Box ref={viewportRef} width=\"100%\">\n          <Box overflow={debug ? undefined : \"hidden\"} width=\"100%\">\n            <Box\n              ref={contentRef}\n              width=\"100%\"\n              flexDirection=\"column\"\n              marginTop={-scrollOffset}\n            >\n              {Children.map(children, (child, index) => {\n                if (!child) return null;\n                return (\n                  <MeasurableItem\n                    key={isValidElement(child) ? child.key || index : index}\n                    index={index}\n                    width={viewportSize.width}\n                    onMeasure={handleItemMeasure}\n                    measureKey={itemMeasureKeys[index]}\n                  >\n                    {child}\n                  </MeasurableItem>\n                );\n              })}\n            </Box>\n          </Box>\n        </Box>\n      </Box>\n    );\n  },\n);\n"],"mappings":"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","names":["useState","useRef","forwardRef","useImperativeHandle","useCallback","key","height","jsx","useStateRef","useState","useRef","useCallback","forwardRef","useImperativeHandle"]}
{"version":3,"sources":["../src/ScrollList.tsx"],"sourcesContent":["/**\n * @file ScrollList.tsx\n * @description A scrollable list component with externally controlled selection for Ink CLI applications.\n *\n * This component provides a high-level abstraction over ink-scroll-view with automatic\n * scroll-into-view behavior when the selected item changes. Unlike traditional list components\n * that manage selection state internally, ScrollList is a fully controlled component where\n * the parent component owns and manages the selection state.\n *\n * @packageDocumentation\n * @module ink-scroll-list\n */\n\nimport {\n  useRef,\n  useEffect,\n  forwardRef,\n  useImperativeHandle,\n  useState,\n  useCallback,\n} from \"react\";\nimport { ScrollViewProps, ScrollViewRef } from \"ink-scroll-view\";\nimport { ControlledScrollView, ControlledScrollViewRef } from \"ink-scroll-view\";\n\n/**\n * Alignment mode for scrolling to items.\n *\n * Determines how the selected item is positioned within the viewport when\n * the component auto-scrolls to make it visible.\n *\n * @remarks\n * - `'auto'`: Performs minimal scrolling to bring the item into view. If the item\n *   is above the viewport, scrolls to show its top. If below, scrolls to show its bottom.\n *   Does not scroll if the item is already fully visible.\n * - `'top'`: Always aligns the top of the selected item with the top of the viewport.\n * - `'bottom'`: Always aligns the bottom of the selected item with the bottom of the viewport.\n * - `'center'`: Always centers the selected item vertically within the viewport.\n *\n * All modes respect scroll bounds - the scroll offset will be clamped to valid range\n * (0 to contentHeight - viewportHeight).\n */\nexport type ScrollAlignment = \"auto\" | \"top\" | \"bottom\" | \"center\";\n\n/**\n * Props for the ScrollList component.\n *\n * @remarks\n * Extends {@link ScrollViewProps} from ink-scroll-view and adds externally controlled\n * selection with automatic scroll-into-view behavior.\n *\n * **Key Differences from Previous Versions**:\n * - Selection state is now fully controlled by the parent (no internal state)\n * - Removed `onSelectionChange` callback (parent manages state directly)\n * - Removed imperative selection methods (`select`, `selectNext`, etc.)\n */\nexport interface ScrollListProps extends ScrollViewProps {\n  /**\n   * The currently selected item index (controlled by parent).\n   *\n   * @remarks\n   * When this value changes, the component will automatically scroll to ensure\n   * the selected item is visible in the viewport according to the `scrollAlignment` mode.\n   *\n   * **Important Behaviors**:\n   * - The selection state is entirely controlled by the parent component.\n   * - Invalid indices (negative or >= item count) are handled gracefully - no scrolling occurs.\n   * - When `undefined`, the component does not perform auto-scrolling (useful for manual scroll control).\n   * - The component does NOT clamp or modify this value - the parent is responsible for bounds checking.\n   *\n   * @example\n   * ```tsx\n   * const [selectedIndex, setSelectedIndex] = useState(0);\n   *\n   * useInput((input, key) => {\n   *   if (key.downArrow) {\n   *     setSelectedIndex(prev => Math.min(prev + 1, items.length - 1));\n   *   }\n   * });\n   *\n   * <ScrollList selectedIndex={selectedIndex}>\n   *   {items.map((item, i) => <ListItem key={i} selected={i === selectedIndex} />)}\n   * </ScrollList>\n   * ```\n   */\n  selectedIndex?: number;\n\n  /**\n   * Alignment mode when scrolling to the selected item.\n   *\n   * @remarks\n   * Controls how the selected item is positioned within the viewport when auto-scrolling.\n   *\n   * **Modes**:\n   * - `'auto'`: Minimal scrolling to bring item into view (default). Best for keyboard navigation.\n   * - `'top'`: Align item to the top of the viewport. Good for \"jump to\" navigation.\n   * - `'bottom'`: Align item to the bottom of the viewport.\n   * - `'center'`: Align item to the center of the viewport. Best for search result highlighting.\n   *\n   * **Examples**:\n   * ```tsx\n   * // Default auto behavior - minimal scrolling\n   * <ScrollList selectedIndex={index} scrollAlignment=\"auto\" />\n   *\n   * // Always center the selected item - good for search/spotlight UX\n   * <ScrollList selectedIndex={searchResultIndex} scrollAlignment=\"center\" />\n   * ```\n   *\n   * @defaultValue `'auto'`\n   */\n  scrollAlignment?: ScrollAlignment;\n}\n\n/**\n * Ref interface for controlling the ScrollList programmatically.\n *\n * @remarks\n * Extends {@link ScrollViewRef} from ink-scroll-view. Since selection is now controlled\n * externally via props, this interface no longer includes selection-related methods.\n *\n * **Scroll Constraint Behavior**:\n * When a `selectedIndex` is set, all scroll methods (`scrollTo`, `scrollBy`, `scrollToTop`,\n * `scrollToBottom`) are constrained to keep the selected item visible in the viewport.\n * This prevents accidentally scrolling the selection out of view.\n *\n * For items larger than the viewport, scrolling is allowed within the item's bounds,\n * letting users view different parts of the large item while keeping at least part\n * of it visible.\n *\n * **Available Methods** (inherited from ScrollViewRef):\n * - `scrollTo(y)`: Scroll to a specific offset (constrained if selected item exists)\n * - `scrollBy(delta)`: Scroll by a relative amount (constrained)\n * - `scrollToTop()`: Scroll as far up as possible while keeping selection visible\n * - `scrollToBottom()`: Scroll as far down as possible while keeping selection visible\n * - `getScrollOffset()`: Get the current scroll offset\n * - `getContentHeight()`: Get the total content height\n * - `getViewportHeight()`: Get the viewport height\n * - `getBottomOffset()`: Get the offset from the bottom\n * - `getItemHeight(index)`: Get a specific item's height\n * - `getItemPosition(index)`: Get a specific item's position (top and height)\n * - `remeasure()`: Force remeasurement of all items\n * - `remeasureItem(index)`: Force remeasurement of a specific item\n *\n * **Note**: Unlike previous versions, there are no selection methods (select, selectNext, etc.)\n * as selection is now controlled externally via the `selectedIndex` prop.\n */\nexport interface ScrollListRef extends ScrollViewRef {}\n\n/**\n * A scrollable list with externally controlled selection.\n *\n * @remarks\n * This component extends {@link ScrollView} from ink-scroll-view to provide:\n * - **Externally controlled selection**: Selection state is managed by the parent via `selectedIndex` prop\n * - **Automatic scroll-into-view**: When `selectedIndex` changes, the component scrolls to ensure visibility\n * - **Configurable alignment**: Control how selected items are positioned within the viewport\n * - **Responsive to layout changes**: Maintains selected item visibility when viewport or content changes\n *\n * ## Design Philosophy\n *\n * ScrollList follows the \"controlled component\" pattern where the parent component owns all state.\n * This provides several benefits:\n * - **Predictable behavior**: The parent always knows the current selection\n * - **Easy integration**: Works seamlessly with state management libraries\n * - **Flexible input handling**: Parent decides how keyboard/mouse events affect selection\n * - **Testable**: Selection logic lives in the parent and is easy to unit test\n *\n * ## Automatic Scroll Behavior\n *\n * The component automatically scrolls to keep the selected item visible in these scenarios:\n * 1. When `selectedIndex` prop changes\n * 2. When viewport size changes (e.g., terminal resize)\n * 3. When content height changes (e.g., items added/removed)\n * 4. When an item's height changes and it affects the selected item's position\n *\n * ## Important Caveats\n *\n * - **No input handling**: This component does NOT handle keyboard input.\n *   Use `useInput` from Ink to update `selectedIndex` in the parent.\n * - **No resize detection**: Does NOT automatically respond to terminal resize.\n *   Listen to `process.stdout`'s `resize` event and call `remeasure()` on the ref.\n * - **Parent manages bounds**: The component does NOT clamp `selectedIndex`.\n *   The parent should ensure the value is within valid range [0, itemCount - 1].\n *\n * @example\n * ### Basic Usage with Keyboard Navigation\n * ```tsx\n * import React, { useRef, useState } from 'react';\n * import { Box, Text, useInput } from 'ink';\n * import { ScrollList, ScrollListRef } from 'ink-scroll-list';\n *\n * const Demo = () => {\n *   const listRef = useRef<ScrollListRef>(null);\n *   const [selectedIndex, setSelectedIndex] = useState(0);\n *   const items = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry'];\n *\n *   // Handle keyboard navigation\n *   useInput((input, key) => {\n *     if (key.downArrow) {\n *       setSelectedIndex(prev => Math.min(prev + 1, items.length - 1));\n *     }\n *     if (key.upArrow) {\n *       setSelectedIndex(prev => Math.max(prev - 1, 0));\n *     }\n *     if (input === 'g') {\n *       setSelectedIndex(0); // Go to first\n *     }\n *     if (input === 'G') {\n *       setSelectedIndex(items.length - 1); // Go to last\n *     }\n *   });\n *\n *   return (\n *     <ScrollList\n *       ref={listRef}\n *       height={5}\n *       selectedIndex={selectedIndex}\n *     >\n *       {items.map((item, i) => (\n *         <Box key={i}>\n *           <Text color={i === selectedIndex ? 'blue' : 'white'}>\n *             {i === selectedIndex ? '> ' : '  '}{item}\n *           </Text>\n *         </Box>\n *       ))}\n *     </ScrollList>\n *   );\n * };\n * ```\n *\n * @example\n * ### With Different Alignment Modes\n * ```tsx\n * // Center alignment - great for search results or spotlight features\n * <ScrollList\n *   height={10}\n *   selectedIndex={searchResultIndex}\n *   scrollAlignment=\"center\"\n * >\n *   {results.map((result, i) => (\n *     <SearchResult key={i} result={result} highlighted={i === searchResultIndex} />\n *   ))}\n * </ScrollList>\n *\n * // Top alignment - always shows selected item at top\n * <ScrollList\n *   height={5}\n *   selectedIndex={selectedIndex}\n *   scrollAlignment=\"top\"\n * >\n *   {items.map((item, i) => <Item key={i} {...item} />)}\n * </ScrollList>\n * ```\n */\nexport const ScrollList = forwardRef<ScrollListRef, ScrollListProps>(\n  (props, ref) => {\n    // =========================================================================\n    // Props Destructuring\n    // =========================================================================\n    const {\n      children,\n      selectedIndex,\n      scrollAlignment = \"auto\",\n      onScroll,\n      onViewportSizeChange,\n      onContentHeightChange,\n      onItemHeightChange,\n      ...boxProps\n    } = props;\n\n    // =========================================================================\n    // Refs\n    // =========================================================================\n\n    /**\n     * Reference to the underlying ScrollView component.\n     * Used to delegate scroll operations and query layout information.\n     */\n    const scrollViewRef = useRef<ControlledScrollViewRef>(null);\n\n    /**\n     * Internal scroll offset state.\n     * Replaces uncontrolled ScrollView state to ensure atomic updates with selection.\n     */\n    const [scrollOffset, setScrollOffset] = useState(0);\n    const scrollOffsetRef = useRef(0);\n    // Sync ref with state asynchronously to avoid blocking render cycles\n    useEffect(() => {\n      scrollOffsetRef.current = scrollOffset;\n    }, [scrollOffset]);\n\n    // Helper to update scroll state and fire callback\n    const updateScroll = useCallback(\n      (newOffset: number) => {\n        if (newOffset !== scrollOffsetRef.current) {\n          setScrollOffset(newOffset);\n          onScroll?.(newOffset);\n        }\n      },\n      [onScroll],\n    );\n\n    /**\n     * Ref to store the current selectedIndex for use in callbacks.\n     *\n     * This is necessary because the callback functions (handleViewportSizeChange, etc.)\n     * are memoized with useCallback, and we need to access the latest selectedIndex\n     * value without including it in the dependency array (which would cause\n     * unnecessary re-creations of the callbacks).\n     */\n    const selectedIndexRef = useRef(selectedIndex);\n    selectedIndexRef.current = selectedIndex;\n\n    // =========================================================================\n    // Internal Helper Functions\n    // =========================================================================\n\n    /**\n     * Calculates the scroll offset bounds that keep the selected item visible.\n     *\n     * @internal\n     * @returns An object with `min` and `max` scroll offsets, or `null` if no\n     *          selected item or selection is invalid.\n     *\n     * @remarks\n     * When a selected item exists, scrolling should be constrained so the item\n     * remains visible in the viewport. The valid scroll range is:\n     * - **min**: The offset where the selected item is at the BOTTOM of the viewport\n     *   - `min = itemTop + itemHeight - viewportHeight`\n     * - **max**: The offset where the selected item is at the TOP of the viewport\n     *   - `max = itemTop`\n     *\n     * **Normal case (itemHeight <= viewportHeight)**:\n     * - Example: Item at position 10, height 1, viewport 5\n     * - min = 10 + 1 - 5 = 6 (item at bottom of viewport)\n     * - max = 10 (item at top of viewport)\n     * - Valid scroll range: [6, 10]\n     *\n     * **Large item case (itemHeight > viewportHeight)**:\n     * - Example: Item at position 5, height 10, viewport 5\n     * - Calculated min = 5 + 10 - 5 = 10, max = 5\n     * - Since min > max, we swap them to allow scrolling within the item\n     * - This lets users scroll to see different parts of the large item\n     * - Valid scroll range: [5, 10] (from item top to item bottom minus viewport)\n     */\n    const getSelectionVisibleBounds = useCallback((): {\n      min: number;\n      max: number;\n    } | null => {\n      const currentSelectedIndex = selectedIndexRef.current;\n      if (currentSelectedIndex === undefined || currentSelectedIndex < 0) {\n        return null; // No selection constraint\n      }\n\n      const position =\n        scrollViewRef.current?.getItemPosition(currentSelectedIndex);\n      if (!position) {\n        return null; // Invalid index\n      }\n\n      const viewportHeight = scrollViewRef.current?.getViewportHeight() ?? 0;\n      const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;\n\n      // Calculate bounds where selected item remains visible\n      // min: item at bottom of viewport\n      // max: item at top of viewport\n      let minOffset = position.top + position.height - viewportHeight;\n      let maxOffset = position.top;\n\n      // Handle large items (height > viewport)\n      // When item is larger than viewport, swap min/max to allow scrolling within the item\n      if (minOffset > maxOffset) {\n        [minOffset, maxOffset] = [maxOffset, minOffset];\n      }\n\n      // Also clamp to global scroll bounds\n      const globalMaxScroll = Math.max(0, contentHeight - viewportHeight);\n\n      return {\n        min: Math.max(0, minOffset),\n        max: Math.min(globalMaxScroll, maxOffset),\n      };\n    }, []);\n\n    /**\n     * Clamps a scroll offset to keep the selected item visible.\n     *\n     * @internal\n     * @param targetOffset - The desired scroll offset\n     * @returns The clamped offset that keeps the selected item visible\n     *\n     * @remarks\n     * If there's no selected item, only clamps to global scroll bounds [0, maxScroll].\n     * If there IS a selected item, additionally constrains to keep it visible.\n     */\n    const clampToSelectionBounds = useCallback(\n      (targetOffset: number): number => {\n        const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;\n        const viewportHeight = scrollViewRef.current?.getViewportHeight() ?? 0;\n        const globalMaxScroll = Math.max(0, contentHeight - viewportHeight);\n\n        // First clamp to global bounds\n        let clampedOffset = Math.max(\n          0,\n          Math.min(targetOffset, globalMaxScroll),\n        );\n\n        // Then apply selection constraint if applicable\n        const selectionBounds = getSelectionVisibleBounds();\n        if (selectionBounds) {\n          // Clamp to the range that keeps selected item visible\n          clampedOffset = Math.max(\n            selectionBounds.min,\n            Math.min(clampedOffset, selectionBounds.max),\n          );\n        }\n\n        return clampedOffset;\n      },\n      [getSelectionVisibleBounds],\n    );\n\n    /**\n     * Scrolls the viewport to make a specific item visible according to the alignment mode.\n     *\n     * @internal\n     * @param index - The index of the item to scroll to\n     * @param mode - The alignment mode to use (defaults to component's scrollAlignment prop)\n     * @param viewportHeightOverride - Optional override for viewport height (used during resize)\n     *\n     * @remarks\n     * This function handles all the scroll position calculations including:\n     * - Looking up the item's position via getItemPosition\n     * - Calculating the target scroll offset based on alignment mode\n     * - Clamping the result to valid scroll bounds [0, maxScroll]\n     * - Only scrolling if the target differs from current position\n     *\n     * **Alignment Mode Calculations**:\n     * - `top`: offset = itemTop\n     * - `bottom`: offset = itemTop + itemHeight - viewportHeight\n     * - `center`: offset = itemTop + itemHeight/2 - viewportHeight/2\n     * - `auto`: minimal scroll - only adjusts if item is outside viewport\n     */\n    const getConstrainedScrollOffset = useCallback(\n      (\n        index: number,\n        currentOffset: number,\n        mode: ScrollAlignment,\n        viewportHeightOverride?: number,\n      ): number => {\n        const position = scrollViewRef.current?.getItemPosition(index);\n        // If ref is not ready or measurement missing, return current\n        if (!position) return currentOffset;\n\n        const viewportHeight =\n          viewportHeightOverride ??\n          scrollViewRef.current?.getViewportHeight() ??\n          0;\n        const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;\n\n        let target = currentOffset;\n\n        // Alignment logic\n        if (mode === \"top\") {\n          target = position.top;\n        } else if (mode === \"bottom\") {\n          target = position.top + position.height - viewportHeight;\n        } else if (mode === \"center\") {\n          target = position.top + position.height / 2 - viewportHeight / 2;\n        } else {\n          // Auto\n          const itemBottom = position.top + position.height;\n          // Check if item is already fully visible OR filling the viewport (for large items)\n          const isFillingViewport =\n            position.top <= currentOffset &&\n            itemBottom >= currentOffset + viewportHeight;\n\n          if (isFillingViewport) {\n            target = currentOffset;\n          } else if (position.top < currentOffset) {\n            target = position.top;\n          } else if (itemBottom > currentOffset + viewportHeight) {\n            target = itemBottom - viewportHeight;\n          }\n        }\n\n        // Clamp to global bounds\n        const maxScroll = Math.max(0, contentHeight - viewportHeight);\n        return Math.max(0, Math.min(target, maxScroll));\n      },\n      [],\n    );\n\n    // Calculate effective scroll offset during render (Derived State)\n    let renderScrollOffset = scrollOffset;\n    if (selectedIndex !== undefined && selectedIndex >= 0) {\n      renderScrollOffset = getConstrainedScrollOffset(\n        selectedIndex,\n        scrollOffset,\n        scrollAlignment,\n      );\n    }\n\n    /**\n     * Effect: Commit scroll offset changes.\n     *\n     * @remarks\n     * We use `useEffect` instead of `useLayoutEffect` to avoid \"jitter\" or flickering.\n     * Letting the render commit first and then updating the scroll state ensures smoother\n     * visual transitions and prevents potential conflicts during the synchronous layout phase.\n     */\n    useEffect(() => {\n      if (renderScrollOffset !== scrollOffset) {\n        updateScroll(renderScrollOffset);\n      }\n    }, [renderScrollOffset, scrollOffset, updateScroll]);\n\n    /**\n     * Legacy scrollToIndex wrapper for internal use if needed,\n     * though we prefer direct state updates now.\n     */\n    const scrollToIndex = useCallback(\n      (\n        index: number,\n        mode: ScrollAlignment = scrollAlignment,\n        viewportHeightOverride?: number,\n      ) => {\n        const newOffset = getConstrainedScrollOffset(\n          index,\n          scrollOffset,\n          mode,\n          viewportHeightOverride,\n        );\n        updateScroll(newOffset);\n      },\n      [getConstrainedScrollOffset, scrollOffset, scrollAlignment, updateScroll],\n    );\n\n    // =========================================================================\n    // Effects\n    // =========================================================================\n\n    /**\n     * Effect: Scroll to selected item when selectedIndex changes.\n     *\n     * This is the primary effect that implements the auto-scroll-into-view behavior.\n     * Whenever the parent updates the selectedIndex prop, this effect ensures\n     * the newly selected item is visible in the viewport.\n     *\n     * @remarks\n     * - Only triggers for valid indices (>= 0)\n     * - Undefined selectedIndex means \"no auto-scroll\" mode\n     */\n\n    // =========================================================================\n    // Event Handlers\n    // =========================================================================\n\n    /**\n     * Handles viewport size changes (e.g., terminal resize).\n     *\n     * When the viewport dimensions change, we need to re-scroll to ensure\n     * the selected item is still visible. This is especially important when\n     * the viewport shrinks - an item that was visible may become hidden.\n     *\n     * @param size - New viewport dimensions\n     * @param previousSize - Previous viewport dimensions\n     */\n    const handleViewportSizeChange = useCallback(\n      (\n        size: { width: number; height: number },\n        previousSize: { width: number; height: number },\n      ) => {\n        // Re-scroll to keep selected item visible with new viewport size\n        // We calculate this \"optimistically\" even if we are not sure if layout settled,\n        // but ScrollView remeasures before calling this.\n        if (\n          selectedIndexRef.current !== undefined &&\n          selectedIndexRef.current >= 0\n        ) {\n          // Pass the new height to avoid stale value during resize\n          const newOffset = getConstrainedScrollOffset(\n            selectedIndexRef.current,\n            scrollOffset,\n            scrollAlignment,\n            size.height,\n          );\n          updateScroll(newOffset);\n        }\n        // Forward callback to parent\n        onViewportSizeChange?.(size, previousSize);\n      },\n      [onViewportSizeChange, scrollToIndex],\n    );\n\n    /**\n     * Handles individual item height changes (e.g., accordion expand/collapse).\n     *\n     * When an item's height changes, it can affect the position of all items below it.\n     * This handler ensures the selected item remains at the same visual position\n     * or becomes visible if it was affected.\n     *\n     * @param index - Index of the item that changed height\n     * @param height - New height of the item\n     * @param previousHeight - Previous height of the item\n     *\n     * @remarks\n     * **Strategy**:\n     * - If the changed item is ABOVE the selected item: Adjust scroll offset by the height delta\n     *   to keep the selected item at the same visual position.\n     * - If the changed item IS the selected item: Re-scroll to ensure it's visible\n     *   (in case it grew larger than the viewport).\n     * - If the changed item is BELOW the selected item: No action needed.\n     */\n    const handleItemHeightChange = useCallback(\n      (index: number, height: number, previousHeight: number) => {\n        const currentSelectedIndex = selectedIndexRef.current;\n        if (currentSelectedIndex !== undefined && currentSelectedIndex >= 0) {\n          if (index < currentSelectedIndex) {\n            // Item above selected changed - compensate scroll offset\n            // This keeps the selected item at the same visual position\n            // But we must clamp it to be safe\n            const newOffset = clampToSelectionBounds(\n              scrollOffset + (height - previousHeight),\n            );\n            updateScroll(newOffset);\n          } else if (index === currentSelectedIndex) {\n            // Selected item itself changed - ensure it's still visible\n            const newOffset = getConstrainedScrollOffset(\n              index,\n              scrollOffset,\n              scrollAlignment,\n            );\n            updateScroll(newOffset);\n          }\n          // Items below selected don't affect its position\n        }\n        // Forward callback to parent\n        onItemHeightChange?.(index, height, previousHeight);\n      },\n      [\n        onItemHeightChange,\n        onItemHeightChange,\n        getConstrainedScrollOffset,\n        scrollAlignment,\n        scrollOffset,\n        clampToSelectionBounds,\n        updateScroll,\n      ],\n    );\n\n    /**\n     * Handles overall content height changes (e.g., items added/removed, text wrapping).\n     *\n     * When the total content height changes, the scroll bounds change as well.\n     * We re-scroll to ensure the selected item remains visible and the scroll\n     * position is within valid bounds.\n     *\n     * @param height - New total content height\n     * @param previousHeight - Previous total content height\n     */\n    const handleContentHeightChange = useCallback(\n      (height: number, previousHeight: number) => {\n        // Re-scroll to keep selected item visible after content changes\n        if (\n          selectedIndexRef.current !== undefined &&\n          selectedIndexRef.current >= 0\n        ) {\n          scrollToIndex(selectedIndexRef.current); // Use the imperative logic? No, updateScroll.\n          const newOffset = getConstrainedScrollOffset(\n            selectedIndexRef.current,\n            scrollOffset,\n            scrollAlignment,\n          );\n          updateScroll(newOffset);\n        }\n        // Forward callback to parent\n        onContentHeightChange?.(height, previousHeight);\n      },\n      [onContentHeightChange, scrollToIndex],\n    );\n\n    // =========================================================================\n    // Imperative Handle (Ref API)\n    // =========================================================================\n\n    /**\n     * Exposes a subset of ScrollView methods to the parent via ref.\n     *\n     * @remarks\n     * This component enforces strict scroll bounds - you cannot scroll past\n     * the content to show empty space at the bottom, unlike the base ScrollView\n     * which might allow it.\n     *\n     * **Available Methods**:\n     * - Scroll control: scrollTo, scrollBy, scrollToTop, scrollToBottom\n     * - State queries: getScrollOffset, getContentHeight, getViewportHeight, getBottomOffset\n     * - Item queries: getItemHeight, getItemPosition\n     * - Measurement: remeasure, remeasureItem\n     */\n    useImperativeHandle(\n      ref,\n      () => ({\n        /**\n         * Scrolls to a specific Y offset.\n         *\n         * @param y - Target scroll offset\n         * @remarks\n         * - Clamps to valid bounds [0, maxScroll]\n         * - If a selected item exists, additionally constrains scroll to keep it visible\n         */\n        scrollTo: (y: number) => {\n          const clampedY = clampToSelectionBounds(y);\n          updateScroll(clampedY);\n        },\n\n        /**\n         * Scrolls by a relative amount.\n         *\n         * @param delta - Amount to scroll (positive = down, negative = up)\n         * @remarks\n         * - Clamps result to valid bounds\n         * - If a selected item exists, additionally constrains scroll to keep it visible\n         */\n        scrollBy: (delta: number) => {\n          const currentOffset = scrollOffsetRef.current;\n          const clampedY = clampToSelectionBounds(currentOffset + delta);\n          updateScroll(clampedY);\n        },\n\n        /**\n         * Scrolls to the top (offset 0), or as close as possible while keeping selected item visible.\n         *\n         * @remarks If a selected item exists, scrolls to the minimum offset that keeps it visible.\n         */\n        scrollToTop: () => {\n          const clampedY = clampToSelectionBounds(0);\n          updateScroll(clampedY);\n        },\n\n        /**\n         * Scrolls to the bottom, or as close as possible while keeping selected item visible.\n         *\n         * @remarks If a selected item exists, scrolls to the maximum offset that keeps it visible.\n         */\n        scrollToBottom: () => {\n          const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;\n          const viewportHeight =\n            scrollViewRef.current?.getViewportHeight() ?? 0;\n          const maxScroll = Math.max(0, contentHeight - viewportHeight);\n          const clampedY = clampToSelectionBounds(maxScroll);\n          updateScroll(clampedY);\n        },\n\n        /** @returns Current scroll offset in lines */\n        getScrollOffset: () => scrollOffsetRef.current,\n\n        /** @returns Total content height in lines */\n        getContentHeight: () => scrollViewRef.current?.getContentHeight() ?? 0,\n\n        /** @returns Viewport height in lines */\n        getViewportHeight: () =>\n          scrollViewRef.current?.getViewportHeight() ?? 0,\n\n        /** @returns Distance from current scroll position to bottom of content */\n        getBottomOffset: () => scrollViewRef.current?.getBottomOffset() ?? 0,\n\n        /**\n         * Gets the height of a specific item.\n         * @param index - Item index\n         * @returns Item height in lines, or 0 if not found\n         */\n        getItemHeight: (index: number) =>\n          scrollViewRef.current?.getItemHeight(index) ?? 0,\n\n        /**\n         * Gets the position of a specific item.\n         * @param index - Item index\n         * @returns Object with top and height properties, or null if not found\n         */\n        getItemPosition: (index: number) =>\n          scrollViewRef.current?.getItemPosition(index) ?? null,\n\n        /** Forces remeasurement of all items. Call this on terminal resize. */\n        remeasure: () => scrollViewRef.current?.remeasure(),\n\n        /**\n         * Forces remeasurement of a specific item.\n         * @param index - Item index to remeasure\n         */\n        remeasureItem: (index: number) =>\n          scrollViewRef.current?.remeasureItem(index),\n      }),\n      [],\n    );\n\n    // =========================================================================\n    // Render\n    // =========================================================================\n\n    return (\n      <ControlledScrollView\n        ref={scrollViewRef}\n        scrollOffset={renderScrollOffset}\n        onViewportSizeChange={handleViewportSizeChange}\n        onContentHeightChange={handleContentHeightChange}\n        onItemHeightChange={handleItemHeightChange}\n        {...boxProps}\n      >\n        {children}\n      </ControlledScrollView>\n    );\n  },\n);\n"],"mappings":"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","names":[]}
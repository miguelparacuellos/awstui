// src/ScrollList.tsx
import {
  useRef,
  useEffect,
  forwardRef,
  useImperativeHandle,
  useState,
  useCallback
} from "react";
import { ControlledScrollView } from "ink-scroll-view";
import { jsx } from "react/jsx-runtime";
var ScrollList = forwardRef(
  (props, ref) => {
    const {
      children,
      selectedIndex,
      scrollAlignment = "auto",
      onScroll,
      onViewportSizeChange,
      onContentHeightChange,
      onItemHeightChange,
      ...boxProps
    } = props;
    const scrollViewRef = useRef(null);
    const [scrollOffset, setScrollOffset] = useState(0);
    const scrollOffsetRef = useRef(0);
    useEffect(() => {
      scrollOffsetRef.current = scrollOffset;
    }, [scrollOffset]);
    const updateScroll = useCallback(
      (newOffset) => {
        if (newOffset !== scrollOffsetRef.current) {
          setScrollOffset(newOffset);
          onScroll?.(newOffset);
        }
      },
      [onScroll]
    );
    const selectedIndexRef = useRef(selectedIndex);
    selectedIndexRef.current = selectedIndex;
    const getSelectionVisibleBounds = useCallback(() => {
      const currentSelectedIndex = selectedIndexRef.current;
      if (currentSelectedIndex === void 0 || currentSelectedIndex < 0) {
        return null;
      }
      const position = scrollViewRef.current?.getItemPosition(currentSelectedIndex);
      if (!position) {
        return null;
      }
      const viewportHeight = scrollViewRef.current?.getViewportHeight() ?? 0;
      const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;
      let minOffset = position.top + position.height - viewportHeight;
      let maxOffset = position.top;
      if (minOffset > maxOffset) {
        [minOffset, maxOffset] = [maxOffset, minOffset];
      }
      const globalMaxScroll = Math.max(0, contentHeight - viewportHeight);
      return {
        min: Math.max(0, minOffset),
        max: Math.min(globalMaxScroll, maxOffset)
      };
    }, []);
    const clampToSelectionBounds = useCallback(
      (targetOffset) => {
        const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;
        const viewportHeight = scrollViewRef.current?.getViewportHeight() ?? 0;
        const globalMaxScroll = Math.max(0, contentHeight - viewportHeight);
        let clampedOffset = Math.max(
          0,
          Math.min(targetOffset, globalMaxScroll)
        );
        const selectionBounds = getSelectionVisibleBounds();
        if (selectionBounds) {
          clampedOffset = Math.max(
            selectionBounds.min,
            Math.min(clampedOffset, selectionBounds.max)
          );
        }
        return clampedOffset;
      },
      [getSelectionVisibleBounds]
    );
    const getConstrainedScrollOffset = useCallback(
      (index, currentOffset, mode, viewportHeightOverride) => {
        const position = scrollViewRef.current?.getItemPosition(index);
        if (!position) return currentOffset;
        const viewportHeight = viewportHeightOverride ?? scrollViewRef.current?.getViewportHeight() ?? 0;
        const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;
        let target = currentOffset;
        if (mode === "top") {
          target = position.top;
        } else if (mode === "bottom") {
          target = position.top + position.height - viewportHeight;
        } else if (mode === "center") {
          target = position.top + position.height / 2 - viewportHeight / 2;
        } else {
          const itemBottom = position.top + position.height;
          const isFillingViewport = position.top <= currentOffset && itemBottom >= currentOffset + viewportHeight;
          if (isFillingViewport) {
            target = currentOffset;
          } else if (position.top < currentOffset) {
            target = position.top;
          } else if (itemBottom > currentOffset + viewportHeight) {
            target = itemBottom - viewportHeight;
          }
        }
        const maxScroll = Math.max(0, contentHeight - viewportHeight);
        return Math.max(0, Math.min(target, maxScroll));
      },
      []
    );
    let renderScrollOffset = scrollOffset;
    if (selectedIndex !== void 0 && selectedIndex >= 0) {
      renderScrollOffset = getConstrainedScrollOffset(
        selectedIndex,
        scrollOffset,
        scrollAlignment
      );
    }
    useEffect(() => {
      if (renderScrollOffset !== scrollOffset) {
        updateScroll(renderScrollOffset);
      }
    }, [renderScrollOffset, scrollOffset, updateScroll]);
    const scrollToIndex = useCallback(
      (index, mode = scrollAlignment, viewportHeightOverride) => {
        const newOffset = getConstrainedScrollOffset(
          index,
          scrollOffset,
          mode,
          viewportHeightOverride
        );
        updateScroll(newOffset);
      },
      [getConstrainedScrollOffset, scrollOffset, scrollAlignment, updateScroll]
    );
    const handleViewportSizeChange = useCallback(
      (size, previousSize) => {
        if (selectedIndexRef.current !== void 0 && selectedIndexRef.current >= 0) {
          const newOffset = getConstrainedScrollOffset(
            selectedIndexRef.current,
            scrollOffset,
            scrollAlignment,
            size.height
          );
          updateScroll(newOffset);
        }
        onViewportSizeChange?.(size, previousSize);
      },
      [onViewportSizeChange, scrollToIndex]
    );
    const handleItemHeightChange = useCallback(
      (index, height, previousHeight) => {
        const currentSelectedIndex = selectedIndexRef.current;
        if (currentSelectedIndex !== void 0 && currentSelectedIndex >= 0) {
          if (index < currentSelectedIndex) {
            const newOffset = clampToSelectionBounds(
              scrollOffset + (height - previousHeight)
            );
            updateScroll(newOffset);
          } else if (index === currentSelectedIndex) {
            const newOffset = getConstrainedScrollOffset(
              index,
              scrollOffset,
              scrollAlignment
            );
            updateScroll(newOffset);
          }
        }
        onItemHeightChange?.(index, height, previousHeight);
      },
      [
        onItemHeightChange,
        onItemHeightChange,
        getConstrainedScrollOffset,
        scrollAlignment,
        scrollOffset,
        clampToSelectionBounds,
        updateScroll
      ]
    );
    const handleContentHeightChange = useCallback(
      (height, previousHeight) => {
        if (selectedIndexRef.current !== void 0 && selectedIndexRef.current >= 0) {
          scrollToIndex(selectedIndexRef.current);
          const newOffset = getConstrainedScrollOffset(
            selectedIndexRef.current,
            scrollOffset,
            scrollAlignment
          );
          updateScroll(newOffset);
        }
        onContentHeightChange?.(height, previousHeight);
      },
      [onContentHeightChange, scrollToIndex]
    );
    useImperativeHandle(
      ref,
      () => ({
        /**
         * Scrolls to a specific Y offset.
         *
         * @param y - Target scroll offset
         * @remarks
         * - Clamps to valid bounds [0, maxScroll]
         * - If a selected item exists, additionally constrains scroll to keep it visible
         */
        scrollTo: (y) => {
          const clampedY = clampToSelectionBounds(y);
          updateScroll(clampedY);
        },
        /**
         * Scrolls by a relative amount.
         *
         * @param delta - Amount to scroll (positive = down, negative = up)
         * @remarks
         * - Clamps result to valid bounds
         * - If a selected item exists, additionally constrains scroll to keep it visible
         */
        scrollBy: (delta) => {
          const currentOffset = scrollOffsetRef.current;
          const clampedY = clampToSelectionBounds(currentOffset + delta);
          updateScroll(clampedY);
        },
        /**
         * Scrolls to the top (offset 0), or as close as possible while keeping selected item visible.
         *
         * @remarks If a selected item exists, scrolls to the minimum offset that keeps it visible.
         */
        scrollToTop: () => {
          const clampedY = clampToSelectionBounds(0);
          updateScroll(clampedY);
        },
        /**
         * Scrolls to the bottom, or as close as possible while keeping selected item visible.
         *
         * @remarks If a selected item exists, scrolls to the maximum offset that keeps it visible.
         */
        scrollToBottom: () => {
          const contentHeight = scrollViewRef.current?.getContentHeight() ?? 0;
          const viewportHeight = scrollViewRef.current?.getViewportHeight() ?? 0;
          const maxScroll = Math.max(0, contentHeight - viewportHeight);
          const clampedY = clampToSelectionBounds(maxScroll);
          updateScroll(clampedY);
        },
        /** @returns Current scroll offset in lines */
        getScrollOffset: () => scrollOffsetRef.current,
        /** @returns Total content height in lines */
        getContentHeight: () => scrollViewRef.current?.getContentHeight() ?? 0,
        /** @returns Viewport height in lines */
        getViewportHeight: () => scrollViewRef.current?.getViewportHeight() ?? 0,
        /** @returns Distance from current scroll position to bottom of content */
        getBottomOffset: () => scrollViewRef.current?.getBottomOffset() ?? 0,
        /**
         * Gets the height of a specific item.
         * @param index - Item index
         * @returns Item height in lines, or 0 if not found
         */
        getItemHeight: (index) => scrollViewRef.current?.getItemHeight(index) ?? 0,
        /**
         * Gets the position of a specific item.
         * @param index - Item index
         * @returns Object with top and height properties, or null if not found
         */
        getItemPosition: (index) => scrollViewRef.current?.getItemPosition(index) ?? null,
        /** Forces remeasurement of all items. Call this on terminal resize. */
        remeasure: () => scrollViewRef.current?.remeasure(),
        /**
         * Forces remeasurement of a specific item.
         * @param index - Item index to remeasure
         */
        remeasureItem: (index) => scrollViewRef.current?.remeasureItem(index)
      }),
      []
    );
    return /* @__PURE__ */ jsx(
      ControlledScrollView,
      {
        ref: scrollViewRef,
        scrollOffset: renderScrollOffset,
        onViewportSizeChange: handleViewportSizeChange,
        onContentHeightChange: handleContentHeightChange,
        onItemHeightChange: handleItemHeightChange,
        ...boxProps,
        children
      }
    );
  }
);
export {
  ScrollList
};
//# sourceMappingURL=index.js.map
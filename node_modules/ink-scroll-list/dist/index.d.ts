import * as react from 'react';
import { ScrollViewProps, ScrollViewRef } from 'ink-scroll-view';

/**
 * Alignment mode for scrolling to items.
 *
 * Determines how the selected item is positioned within the viewport when
 * the component auto-scrolls to make it visible.
 *
 * @remarks
 * - `'auto'`: Performs minimal scrolling to bring the item into view. If the item
 *   is above the viewport, scrolls to show its top. If below, scrolls to show its bottom.
 *   Does not scroll if the item is already fully visible.
 * - `'top'`: Always aligns the top of the selected item with the top of the viewport.
 * - `'bottom'`: Always aligns the bottom of the selected item with the bottom of the viewport.
 * - `'center'`: Always centers the selected item vertically within the viewport.
 *
 * All modes respect scroll bounds - the scroll offset will be clamped to valid range
 * (0 to contentHeight - viewportHeight).
 */
type ScrollAlignment = "auto" | "top" | "bottom" | "center";
/**
 * Props for the ScrollList component.
 *
 * @remarks
 * Extends {@link ScrollViewProps} from ink-scroll-view and adds externally controlled
 * selection with automatic scroll-into-view behavior.
 *
 * **Key Differences from Previous Versions**:
 * - Selection state is now fully controlled by the parent (no internal state)
 * - Removed `onSelectionChange` callback (parent manages state directly)
 * - Removed imperative selection methods (`select`, `selectNext`, etc.)
 */
interface ScrollListProps extends ScrollViewProps {
    /**
     * The currently selected item index (controlled by parent).
     *
     * @remarks
     * When this value changes, the component will automatically scroll to ensure
     * the selected item is visible in the viewport according to the `scrollAlignment` mode.
     *
     * **Important Behaviors**:
     * - The selection state is entirely controlled by the parent component.
     * - Invalid indices (negative or >= item count) are handled gracefully - no scrolling occurs.
     * - When `undefined`, the component does not perform auto-scrolling (useful for manual scroll control).
     * - The component does NOT clamp or modify this value - the parent is responsible for bounds checking.
     *
     * @example
     * ```tsx
     * const [selectedIndex, setSelectedIndex] = useState(0);
     *
     * useInput((input, key) => {
     *   if (key.downArrow) {
     *     setSelectedIndex(prev => Math.min(prev + 1, items.length - 1));
     *   }
     * });
     *
     * <ScrollList selectedIndex={selectedIndex}>
     *   {items.map((item, i) => <ListItem key={i} selected={i === selectedIndex} />)}
     * </ScrollList>
     * ```
     */
    selectedIndex?: number;
    /**
     * Alignment mode when scrolling to the selected item.
     *
     * @remarks
     * Controls how the selected item is positioned within the viewport when auto-scrolling.
     *
     * **Modes**:
     * - `'auto'`: Minimal scrolling to bring item into view (default). Best for keyboard navigation.
     * - `'top'`: Align item to the top of the viewport. Good for "jump to" navigation.
     * - `'bottom'`: Align item to the bottom of the viewport.
     * - `'center'`: Align item to the center of the viewport. Best for search result highlighting.
     *
     * **Examples**:
     * ```tsx
     * // Default auto behavior - minimal scrolling
     * <ScrollList selectedIndex={index} scrollAlignment="auto" />
     *
     * // Always center the selected item - good for search/spotlight UX
     * <ScrollList selectedIndex={searchResultIndex} scrollAlignment="center" />
     * ```
     *
     * @defaultValue `'auto'`
     */
    scrollAlignment?: ScrollAlignment;
}
/**
 * Ref interface for controlling the ScrollList programmatically.
 *
 * @remarks
 * Extends {@link ScrollViewRef} from ink-scroll-view. Since selection is now controlled
 * externally via props, this interface no longer includes selection-related methods.
 *
 * **Scroll Constraint Behavior**:
 * When a `selectedIndex` is set, all scroll methods (`scrollTo`, `scrollBy`, `scrollToTop`,
 * `scrollToBottom`) are constrained to keep the selected item visible in the viewport.
 * This prevents accidentally scrolling the selection out of view.
 *
 * For items larger than the viewport, scrolling is allowed within the item's bounds,
 * letting users view different parts of the large item while keeping at least part
 * of it visible.
 *
 * **Available Methods** (inherited from ScrollViewRef):
 * - `scrollTo(y)`: Scroll to a specific offset (constrained if selected item exists)
 * - `scrollBy(delta)`: Scroll by a relative amount (constrained)
 * - `scrollToTop()`: Scroll as far up as possible while keeping selection visible
 * - `scrollToBottom()`: Scroll as far down as possible while keeping selection visible
 * - `getScrollOffset()`: Get the current scroll offset
 * - `getContentHeight()`: Get the total content height
 * - `getViewportHeight()`: Get the viewport height
 * - `getBottomOffset()`: Get the offset from the bottom
 * - `getItemHeight(index)`: Get a specific item's height
 * - `getItemPosition(index)`: Get a specific item's position (top and height)
 * - `remeasure()`: Force remeasurement of all items
 * - `remeasureItem(index)`: Force remeasurement of a specific item
 *
 * **Note**: Unlike previous versions, there are no selection methods (select, selectNext, etc.)
 * as selection is now controlled externally via the `selectedIndex` prop.
 */
interface ScrollListRef extends ScrollViewRef {
}
/**
 * A scrollable list with externally controlled selection.
 *
 * @remarks
 * This component extends {@link ScrollView} from ink-scroll-view to provide:
 * - **Externally controlled selection**: Selection state is managed by the parent via `selectedIndex` prop
 * - **Automatic scroll-into-view**: When `selectedIndex` changes, the component scrolls to ensure visibility
 * - **Configurable alignment**: Control how selected items are positioned within the viewport
 * - **Responsive to layout changes**: Maintains selected item visibility when viewport or content changes
 *
 * ## Design Philosophy
 *
 * ScrollList follows the "controlled component" pattern where the parent component owns all state.
 * This provides several benefits:
 * - **Predictable behavior**: The parent always knows the current selection
 * - **Easy integration**: Works seamlessly with state management libraries
 * - **Flexible input handling**: Parent decides how keyboard/mouse events affect selection
 * - **Testable**: Selection logic lives in the parent and is easy to unit test
 *
 * ## Automatic Scroll Behavior
 *
 * The component automatically scrolls to keep the selected item visible in these scenarios:
 * 1. When `selectedIndex` prop changes
 * 2. When viewport size changes (e.g., terminal resize)
 * 3. When content height changes (e.g., items added/removed)
 * 4. When an item's height changes and it affects the selected item's position
 *
 * ## Important Caveats
 *
 * - **No input handling**: This component does NOT handle keyboard input.
 *   Use `useInput` from Ink to update `selectedIndex` in the parent.
 * - **No resize detection**: Does NOT automatically respond to terminal resize.
 *   Listen to `process.stdout`'s `resize` event and call `remeasure()` on the ref.
 * - **Parent manages bounds**: The component does NOT clamp `selectedIndex`.
 *   The parent should ensure the value is within valid range [0, itemCount - 1].
 *
 * @example
 * ### Basic Usage with Keyboard Navigation
 * ```tsx
 * import React, { useRef, useState } from 'react';
 * import { Box, Text, useInput } from 'ink';
 * import { ScrollList, ScrollListRef } from 'ink-scroll-list';
 *
 * const Demo = () => {
 *   const listRef = useRef<ScrollListRef>(null);
 *   const [selectedIndex, setSelectedIndex] = useState(0);
 *   const items = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry'];
 *
 *   // Handle keyboard navigation
 *   useInput((input, key) => {
 *     if (key.downArrow) {
 *       setSelectedIndex(prev => Math.min(prev + 1, items.length - 1));
 *     }
 *     if (key.upArrow) {
 *       setSelectedIndex(prev => Math.max(prev - 1, 0));
 *     }
 *     if (input === 'g') {
 *       setSelectedIndex(0); // Go to first
 *     }
 *     if (input === 'G') {
 *       setSelectedIndex(items.length - 1); // Go to last
 *     }
 *   });
 *
 *   return (
 *     <ScrollList
 *       ref={listRef}
 *       height={5}
 *       selectedIndex={selectedIndex}
 *     >
 *       {items.map((item, i) => (
 *         <Box key={i}>
 *           <Text color={i === selectedIndex ? 'blue' : 'white'}>
 *             {i === selectedIndex ? '> ' : '  '}{item}
 *           </Text>
 *         </Box>
 *       ))}
 *     </ScrollList>
 *   );
 * };
 * ```
 *
 * @example
 * ### With Different Alignment Modes
 * ```tsx
 * // Center alignment - great for search results or spotlight features
 * <ScrollList
 *   height={10}
 *   selectedIndex={searchResultIndex}
 *   scrollAlignment="center"
 * >
 *   {results.map((result, i) => (
 *     <SearchResult key={i} result={result} highlighted={i === searchResultIndex} />
 *   ))}
 * </ScrollList>
 *
 * // Top alignment - always shows selected item at top
 * <ScrollList
 *   height={5}
 *   selectedIndex={selectedIndex}
 *   scrollAlignment="top"
 * >
 *   {items.map((item, i) => <Item key={i} {...item} />)}
 * </ScrollList>
 * ```
 */
declare const ScrollList: react.ForwardRefExoticComponent<ScrollListProps & react.RefAttributes<ScrollListRef>>;

export { type ScrollAlignment, ScrollList, type ScrollListProps, type ScrollListRef };
